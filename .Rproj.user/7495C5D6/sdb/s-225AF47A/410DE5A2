{
    "collab_server" : "",
    "contents" : "source(\"initLibrary.R\")\nsource(\"utilityFunction.R\")\n\ngetPathwayGenes <- function(hsa_code){\n  #get list of genes by its symbol for a specified pathway\n  data <- getURL(paste(\"http://togows.dbcls.jp/entry/pathway/\",hsa_code,\"/genes.json\",sep=\"\"))\n  data <- t(fromJSON(data))\n  entrezID <- row.names(data)\n  gene.db[gene.db$EntrezGene.ID%in%entrezID,]\n}\n\nloadKGML <- function(hsa_code){\n  #download KGML file from the server\n  message(\"Get KGML file from the server\")\n  dataXML <- xmlParse(paste(\"http://rest.kegg.jp/get/\",hsa_code,\"/kgml\",sep=\"\"))\n  dataXML <- xmlToList(dataXML)\n  dataXML\n}\n\nKGMLParser <- function(KGML){\n  #parse KGML to get the data, only select entry and relationship type from the KGML\n  #there are several tag in KGML data format. The network information is stored in entry and relationship tag.\n  #entry defined vertices and relationship defined edges\n  #entry in original KEGG network doesn't represent a single gene. It represents a group or a fimily of gene\n  #each entry is given an entry ID and this entry ID is used in relationship data to connect 2 entries in network\n  message(\"get the nodes from the pathway\")\n  \n  entry <- list()\n  idxEntry<-1\n  \n  relation <- list()\n  idxRelation<-1\n  \n  for(i in 1:length(KGML)){\n    if(names(KGML[i])==\"entry\"){\n      entry[[idxEntry]] <- KGML[[i]]\n      idxEntry <- idxEntry+1\n    }else if(names(KGML[i])==\"relation\"){\n      relation[[idxRelation]] <- KGML[[i]]\n      idxRelation <- idxRelation+1\n    }\n  }\n  \n  \n  entry <- lapply(entry,function(x)x[\".attrs\"])\n  entry <- lapply(entry,function(x) as.data.frame(t(x[[1]]),stringsAsFactors=FALSE))\n  entry <- lapply(entry,function(x){\n    if(ncol(x)==4){\n      x\n    }\n  })\n  \n  entry <- do.call(rbind,entry)\n  entry <- entry[entry$type==\"gene\",]\n  list(\"entry\"=entry[entry$type==\"gene\",],\"relationship\"=relationshipDataFormatter(relation))\n}\n\nrelationshipDataFormatter <- function(relation){\n  #format the relationship data extracted from KGML as a table\n  #data extracted from KGML is not formatted. It is just parsed string by R function\n  #this function reformat it to table format\n  message(\"formatting relationship data\")\n  relationship <- c()\n  \n  for(xx in 1:length(relation)){\n    innerList <- relation[[xx]]\n    #innerList consist of subtype and .attrs\n    c <-c()\n    attr <- NULL\n    \n    for(j in 1:length(innerList)){\n      if(names(innerList[j])==\"subtype\"){\n        c<-rbind(c,innerList[[j]])\n      }else{\n        attr <- as.data.frame(t(innerList[[j]]))\n      }\n    }\n    relationship <- rbind(relationship,merge(c,attr))\n  }\n  relationship\n}\n\ncreateRelationshipTable <- function(entry,relationship){\n  #create gene-gene relationnship\n  #it extracts the gene information from entry table\n  #use relationship data based on its entry ID to make gene-gene relationship\n  relationshipTable <- data.frame()\n  for (idx in 1:nrow(relationship)){\n    row <- relationship[idx,]\n    \n    relType <- as.character(levels(relationship$name)[relationship[idx,\"name\"]])\n    en1 <- as.numeric(levels(relationship$entry1)[relationship[idx,\"entry1\"]])\n    en2 <- as.numeric(levels(relationship$entry2)[relationship[idx,\"entry2\"]])\n    \n    entry1 <- entry[entry$id==en1,\"name\"]\n    entry2 <- entry[entry$id==en2,\"name\"]\n    \n    if ((length(entry1) == 0) && (typeof(entry1) == \"character\")){\n      next\n    }\n    if ((length(entry2) == 0) && (typeof(entry2) == \"character\")){\n      next\n    }\n    \n    entry1genes <- strsplit(entry1, \" \")[[1]]\n    entry2genes <- strsplit(entry2, \" \")[[1]]\n    \n    \n    for (gene1 in entry1genes){\n      gene1 <- substring(gene1,5)\n      for (gene2 in entry2genes){\n        gene2 <- substring(gene2,5)\n        newRow <- data.frame(\"relType\"=relType,\"entry1\"=en1,\"entry2\"=en2,stringsAsFactors = FALSE)\n        newRow$gene1 <- gene1\n        newRow$gene2 <- gene2\n        relationshipTable <- rbind(relationshipTable,newRow)\n      }\n    }\n  }\n  relationshipTable\n}\n\ncreateAdjacencyMatrix <- function(relationshipTable,distinct=TRUE){\n  #change the format of relationship table into adjacency matrix\n  #because there is a possibilities for a gene has 2 entry ID, the entry ID is attached to gene name to identify it\n  #it happens if in one KGML, there are several separated network, for example : alternative pathway\n  #the matrix result is : column == target gene, row == TF gene\n  if(distinct){\n    element <- unique(c(paste(relationshipTable$gene1,relationshipTable$entry1,sep=\".\"),paste(relationshipTable$gene2,relationshipTable$entry2,sep=\".\")))\n  }else{\n    element <- unique(c(relationshipTable$gene1,relationshipTable$gene2))\n  }\n  adjMat <- matrix(0, nrow = length(element), ncol = length(element))\n  colnames(adjMat) <- element\n  rownames(adjMat) <- element\n  \n  for (i in 1:nrow(relationshipTable)){\n    r <- relationshipTable[i,]\n    rel <- getKEGGRelationCode(r$relType)\n    if(distinct){\n      adjMat[paste(r$gene1,r$entry1,sep=\".\"),paste(r$gene2,r$entry2,sep=\".\")] <- rel\n    }else{\n      adjMat[r$gene1,r$gene2] <- rel\n    }\n  }\n  adjMat\n}\n\nseparateAdjMatrix <- function(matrix){\n  #for adj matrix which contains more than one pathway,\n  #separate it so that the adj matrix consist only 1 pathway\n  #output is a list of matrix\n  dfs <- function(gene,matrix){\n    evaluated <<- c(evaluated,gene)\n    TFs <- getTF(gene,matrix)\n    if(!is.null(TFs)){\n      for(tf in TFs){\n        if(nrow(tesDFS[tesDFS$TF==tf & tesDFS$Target==gene,])==0){\n          tesDFS <<- rbind(tesDFS,data.frame(\"TF\"=tf,\"Target\"=gene,stringsAsFactors = FALSE))\n        }\n        if(!tf%in%evaluated){\n          dfs(tf,matrix)\n        }\n      }\n    }\n  }\n  \n  resList <- list()\n  \n  for(gene in getEndNode(matrix)){\n    tesDFS <- data.frame()\n    evaluated <- c()\n    dfs(gene,matrix)\n    resList[[gene]]<-tesDFS\n  }\n  resList\n}\n\ngetPathwayRelationshipTable<-function(hsa_code){\n  #get KEGG pathway network in the form of relationship table\n  KGML <- loadKGML(hsa_code)\n  parsedKGML <- KGMLParser(KGML)\n  entry <- parsedKGML[[\"entry\"]]\n  relationship <- parsedKGML[[\"relationship\"]]\n  relationshipTable <- createRelationshipTable(entry,relationship)\n}\n\ngetEndNode <- function(matrix){\n  #get the end node of the network represents in the adj matrix\n  output <- c()\n  for (g in colnames(matrix)){\n    if (is.null(getTarget(g,matrix))){\n      output <- c(output,g)\n    }\n  }\n  output\n}",
    "created" : 1465518974781.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1797444800",
    "id" : "410DE5A2",
    "lastKnownWriteTime" : 1468651469,
    "last_content_update" : 1468651469822,
    "path" : "E://KEGGGraphLoader/KEGGLoader.R",
    "project_path" : "KEGGLoader.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}